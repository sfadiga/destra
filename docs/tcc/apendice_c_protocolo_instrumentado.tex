% ============================================================================
% APÊNDICE C - PROTOCOLO DESTRA INSTRUMENTADO
% ============================================================================
\chapter{Protocolo DESTRA Instrumentado}

\section{Implementação com Instrumentação de Performance}

Este apêndice apresenta a versão instrumentada do protocolo DESTRA, que inclui funcionalidades adicionais para análise de performance em tempo real, coleta de métricas de execução e monitoramento de jitter.

\subsection{Código Completo Instrumentado - destra\_protocol\_test.ino}

\begin{lstlisting}[language=C++, caption={Protocolo DESTRA com instrumentação para análise de performance}, label=lst:destra_protocol_instrumentado, basicstyle=\tiny\ttfamily, breaklines=true, numbers=left, numberstyle=\tiny, stepnumber=1, showstringspaces=false]
/*
 * ============================================================================
 * Arquivo: destra_protocol_test.ino
 * Autor: Sandro Fadiga
 * Instituicao: EESC - USP (Escola de Engenharia de Sao Carlos)
 * Projeto: DESTRA - DEpurador de Sistemas em Tempo ReAl
 * Data de Criacao: 09/01/2025
 * Versao: 1.0
 * 
 * Descricao:
 *   Implementacao do protocolo DESTRA para Arduino.
 *   Este arquivo contem toda a logica de comunicacao serial para
 *   operacoes peek/poke, permitindo leitura e escrita de memoria
 *   em tempo real para depuracao de sistemas embarcados.
 * 
 * Protocolo:
 *   - Palavras magicas: 0xCA 0xFE
 *   - Comandos: PEEK (0xF1), POKE (0xF2)
 *   - Enderecamento: 16 bits (0x0100 - 0x08FF para Arduino Uno)
 *   - Tamanho de dados: 1-8 bytes por operacao
 *   - Comunicacao: Serial 115200 baud, 8N1
 * 
 * Funcionalidades:
 *   - destraSetup(): Inicializa a comunicacao serial
 *   - destraHandler(): Processa comandos recebidos (nao bloqueante)
 *   - processPeekRequest(): Le dados da memoria
 *   - processPokeRequest(): Escreve dados na memoria
 *   - Maquina de estados para parsing de comandos
 *   - Validacao de enderecos e tamanhos
 *   - Echo de confirmacao para todos os bytes recebidos
 * 
 * Formato dos Pacotes:
 *   PEEK: [0xCA][0xFE][0xF1][ADDR_L][ADDR_H][SIZE]
 *   POKE: [0xCA][0xFE][0xF2][ADDR_L][ADDR_H][SIZE][DATA...]
 * 
 * Codigos de Status:
 *   - 0x00: Sucesso
 *   - 0x01: Erro de faixa de endereco
 *   - 0x02: Erro de tamanho
 * 
 * Requisitos:
 *   - Arduino Uno ou compativel
 *   - Memoria RAM acessivel: 0x0100 - 0x08FF
 * 
 * Uso:
 *   1. Incluir este arquivo no projeto Arduino
 *   2. Chamar destraSetup() no setup()
 *   3. Chamar destraHandler() no loop()
 * 
 * Licenca: MIT
 * ============================================================================
 */

#include <Arduino.h>

// Constantes de comunicacao serial
#define SERIAL_START_MARKER 0xCAFE
#define CMD_PEEK 0xF1
#define CMD_POKE 0xF2
#define STATUS_SUCCESS 0x00
#define STATUS_ADDRESS_RANGE_ERROR 0x01
#define STATUS_SIZE_ERROR 0x02
#define BAUD_RATE 115200
#define BUFFER_SIZE 64 // Buffer para dados recebidos

// Estados da maquina de estados serial
enum DestraState {
  WAIT_START_HIGH,
  WAIT_START_LOW,
  WAIT_COMMAND,
  WAIT_ADDRESS_LOW,
  WAIT_ADDRESS_HIGH,
  WAIT_SIZE,
  WAIT_VALUE,
  PROCESS_REQUEST
};

// Variaveis de comunicacao serial
DestraState destraState = WAIT_START_HIGH;
uint8_t destraCommand = 0;
uint16_t destraAddress = 0;  // Endereco de 16 bits
uint8_t destraSize = 0;
uint8_t addressLow = 0;
uint8_t addressHigh = 0;
uint8_t destraValueBuffer[8];  // Buffer para bytes de valor do POKE
uint8_t destraValueIndex = 0;   // Indice para buffer de valor


// ============================================================================
// DEFINICOES E VARIAVEIS PARA ANALISE - INSTRUMENTACAO PROTOCOLO
// ============================================================================
// Comando especial para recuperar logs de performance
#define CMD_GET_PERF_LOG 0xF3

// VARIAVEIS DE PERFORMANCE
volatile unsigned long frameCounter = 0;        // Contador de frames
volatile uint16_t frameRate = 0;                // Frame rate de execucao
volatile uint16_t frameJitter = 0;              // Jitter de processamento do loop
volatile uint16_t commandSequence = 0;          // Identifica o comando
volatile unsigned long commandStartCounter = 0; // Contador de frame inicio do comando, 0 se nao houver comando
volatile unsigned long commandEndCounter = 0;   // Contador de frame do fim do comando, 0 se nao houver comando
volatile unsigned long lastFrameTime = 0;       // Tempo do inicio do frame anterior
volatile unsigned long commandReceiveTime = 0;  // Tempo de recepcao do comando
volatile unsigned long commandProcessTime = 0;  // Tempo de processamento
volatile unsigned long lastDeltaTime = 0;       // Ultimo delta de tempo calculado

// PINOS DE DEBUG PARA OSCILOSCOPIO
#define PIN_TRIGGER_RX 2    // Pulso quando recebe comando
#define PIN_TRIGGER_TX 3    // Pulso quando envia resposta
#define PIN_FRAME_TOGGLE 4  // Toggle a cada loop()
#define PIN_BUSY 5          // Alto durante processamento

// Macros para facilitar uso dos pinos de debug
#define PULSE_RX() { digitalWrite(PIN_TRIGGER_RX, HIGH);  delayMicroseconds(10);  digitalWrite(PIN_TRIGGER_RX, LOW); }
#define PULSE_TX() { digitalWrite(PIN_TRIGGER_TX, HIGH);  delayMicroseconds(10);  digitalWrite(PIN_TRIGGER_TX, LOW); }
#define TOGGLE_FRAME() { digitalWrite(PIN_FRAME_TOGGLE, !digitalRead(PIN_FRAME_TOGGLE)); }
#define SET_BUSY(state) { digitalWrite(PIN_BUSY, state); }

// ESTRUTURA E BUFFER DE PERFORMANCE
#define PERF_BUFFER_SIZE 100
struct PerfLog
{
  unsigned long frameCounter;        // Contador absoluto de frames
  uint16_t frameRate;                // Frame rate
  uint16_t frameJitter;              // Diferenca entre frames consecutivos
  uint16_t commandSequence;          // Identifica o comando
  uint16_t commandFrameCounterDelta; // Distancia do frame executado do frame de inicio do comando, 0 se mesmo frame
  unsigned long commandProcessTime;  // Tempo de execucao do comando atual, 0 se nao houver comando
};
PerfLog perfBuffer[PERF_BUFFER_SIZE];
uint8_t perfIndex = 0;
// ============================================================================
// FIM - DEFINICOES E VARIAVEIS PARA ANALISE - INSTRUMENTACAO PROTOCOLO
// ============================================================================


// ============================================================================
// FUNCOES ARDUINO INSTRUMENTADAS - SETUP  E LOOP
// ============================================================================
void setup() {
    // inicializar Teste
    destraTestSetup();
    // Inicializar DESTRA
    destraSetup();
}

void loop() {
  unsigned long currentFrameTime = micros();
  unsigned long deltaTime = currentFrameTime - lastFrameTime;  // duracao do frame anterior

  // Calcular framerate (Hz)
  if (deltaTime > 0) {
    frameRate = 1000000.0 / deltaTime;
  }

  // Calcular jitter (diferenca absoluta entre periodos consecutivos)
  frameJitter = abs((long)deltaTime - (long)lastDeltaTime);
  lastDeltaTime = deltaTime;

  // Toggle do pino de frame
  TOGGLE_FRAME();
  frameCounter++;

  // Processar comandos DESTRA
  destraHandler();

  // Executar calculos de exemplo
  calculation();

  // Ajustar para ~100Hz (10ms)
  unsigned long elapsed = micros() - currentFrameTime;
  if (elapsed < 10000) {
    delayMicroseconds(10000 - elapsed);
  }

  lastFrameTime = currentFrameTime;
}

// Usaer em conjunto com Destra Setup 
void destraTestSetup() {
  // Configurar pinos de debug
  pinMode(PIN_TRIGGER_RX, OUTPUT);
  pinMode(PIN_TRIGGER_TX, OUTPUT);
  pinMode(PIN_FRAME_TOGGLE, OUTPUT);
  pinMode(PIN_BUSY, OUTPUT);

  // Inicializar pinos em LOW
  digitalWrite(PIN_TRIGGER_RX, LOW);
  digitalWrite(PIN_TRIGGER_TX, LOW);
  digitalWrite(PIN_FRAME_TOGGLE, LOW);
  digitalWrite(PIN_BUSY, LOW);
}

// Destra Setup Original
void destraSetup() {
  // Inicializar comunicacao serial
  Serial.begin(BAUD_RATE);
  // Aguardar conexao da porta serial (necessario para placas USB nativas)
  while (!Serial) {
    ; // Aguardar conexao da porta serial
  }
  destraState = WAIT_START_HIGH;
}

// Coloque-me no inicio do seu loop()
void destraHandler() {
// Funcao para lidar com comunicacao serial destra (nao bloqueante)
  while (Serial.available() > 0 && destraState != PROCESS_REQUEST) {
    uint8_t inByte = Serial.read();
  
    // Maquina de Estados do Pacote/Requisicao     
    switch (destraState) {
      // Pacote PEEK/POKE comeca com 0xCAFE
      case WAIT_START_HIGH:
        if (inByte == 0xCA) {
          int bytesAvailable = Serial.availableForWrite();
          destraState = WAIT_START_LOW;
          
          // // INTRUMENTACAO - Pulso RX no primeiro byte de um novo comando
          PULSE_RX();
          commandReceiveTime = micros();
          commandStartCounter = frameCounter;
          SET_BUSY(HIGH);

        }
        break;
        
      case WAIT_START_LOW:
        if (inByte == 0xFE) {
          destraState = WAIT_COMMAND;
        } else {
          destraState = WAIT_START_HIGH;
          SET_BUSY(LOW); // INTRUMENTACAO
        }
        break;
        
      case WAIT_COMMAND:
        destraCommand = inByte;
        if (inByte == CMD_PEEK || inByte == CMD_POKE) {
          destraState = WAIT_ADDRESS_LOW;
        } 
        else if (inByte == CMD_GET_PERF_LOG) {
          destraState = PROCESS_REQUEST;
        } 
        else {
          destraState = WAIT_START_HIGH;
          SET_BUSY(LOW); // INTRUMENTACAO
        }
        break;
        
      case WAIT_ADDRESS_LOW:
        addressLow = inByte;
        destraState = WAIT_ADDRESS_HIGH;
        break;
        
      case WAIT_ADDRESS_HIGH:
        addressHigh = inByte;
        // Combinar para endereco de 16 bits (little endian)
        destraAddress = addressLow | (addressHigh << 8);
        destraState = WAIT_SIZE;
        break;
        
      case WAIT_SIZE:
        destraSize = inByte;
        if (destraCommand == CMD_PEEK) {
          destraState = PROCESS_REQUEST;
        }
        else if (destraCommand == CMD_POKE) {
          destraValueIndex = 0;  // Resetar indice do buffer de valor
          destraState = WAIT_VALUE;
        }
        else {
          destraState = WAIT_START_HIGH;
          SET_BUSY(LOW); // INTRUMENTACAO
        }
        break;

      case WAIT_VALUE:
        // Verificar se o indice esta dentro dos limites do buffer
        if (destraValueIndex < 8 && destraValueIndex < destraSize) {
          // Armazenar o byte de valor
          destraValueBuffer[destraValueIndex] = inByte;
          destraValueIndex++;
        }
        // Verificar se recebemos todos os bytes de valor
        if (destraValueIndex >= destraSize) {
          destraState = PROCESS_REQUEST;
        }
        // Caso contrario, permanecer em WAIT_VALUE para coletar mais bytes
        break;
    }
  }
  
  // Processar a requisicao se tivermos uma mensagem completa
  if (destraState == PROCESS_REQUEST) {
    if (destraCommand == CMD_PEEK) {
      processPeekRequest();
    } else if (destraCommand == CMD_POKE) {
      processPokeRequest();
    } 
    else if (destraCommand == CMD_GET_PERF_LOG) {
      processGetPerfLog();
    }
    destraCommand = 0;
    destraState = WAIT_START_HIGH;  // Resetar para proxima requisicao

    // INTRUMENTACAO - Registrar tempo de processamento
    SET_BUSY(LOW);
    commandEndCounter = frameCounter;
    commandProcessTime = micros() - commandReceiveTime;
    commandSequence++;
    registerPerformanceStats();
  }
}


// Funcao para processar requisicao peek e enviar resposta
void processPeekRequest() {
  // INTRUMENTACAO - Pulso TX antes de enviar resposta
  PULSE_TX();

  // Enviar cabecalho da resposta
  Serial.write(0xCA);
  Serial.write(0xFE);
  Serial.write(CMD_PEEK);
  
  // Validar faixa de endereco (verificacao de seguranca opcional)
  if (destraAddress < 0x100 || destraAddress > 0x8FF) {  // Faixa de RAM do Arduino Uno
    Serial.write(STATUS_ADDRESS_RANGE_ERROR);
    return;
  }

  // Validar tamanho
  if (destraSize == 0 || destraSize > 8) {
    Serial.write(STATUS_SIZE_ERROR);
    return;
  }
  
  Serial.write(STATUS_SUCCESS);
  
  // Ler e enviar os dados solicitados
  uint8_t* ptr = (uint8_t*)destraAddress;
  for (uint8_t i = 0; i < destraSize; i++) {
    Serial.write(ptr[i]);
  }
}


// Funcao para processar requisicao poke e enviar resposta
void processPokeRequest() {
  // INTRUMENTACAO - Pulso TX antes de enviar resposta
  PULSE_TX();
    
  // Enviar cabecalho da resposta
  Serial.write(0xCA);
  Serial.write(0xFE);
  Serial.write(CMD_POKE);
  
  // Validar faixa de endereco
  if (destraAddress < 0x100 || destraAddress > 0x8FF) {  // Faixa de RAM do Arduino Uno
    Serial.write(STATUS_ADDRESS_RANGE_ERROR);
    return;
  }

  // Validar tamanho (ja verificado na maquina de estados, mas dupla verificacao)
  if (destraSize == 0 || destraSize > 8) {
    Serial.write(STATUS_SIZE_ERROR);
    return;
  }
  
  // Escrever os dados na memoria
  uint8_t* ptr = (uint8_t*)destraAddress;
  for (uint8_t i = 0; i < destraSize; i++) {
    ptr[i] = destraValueBuffer[i];
  }
  
  // Enviar status de sucesso
  Serial.write(STATUS_SUCCESS);
  
  // Opcionalmente, ecoar de volta os dados escritos para verificacao
  // Isso ajuda a confirmar que a escrita foi bem-sucedida
  for (uint8_t i = 0; i < destraSize; i++) {
    Serial.write(ptr[i]);  // Ler de volta da memoria e enviar
  }
}

// INTRUMENTACAO - Funcao para processar a requisicao de performance e enviar resposta
void sendPerfLogEntry(const PerfLog& e) {
    Serial.write((uint8_t*)&e.frameCounter, 4);
    Serial.write((uint8_t*)&e.frameRate, 2);
    Serial.write((uint8_t*)&e.frameJitter, 2);
    Serial.write((uint8_t*)&e.commandSequence, 2);
    Serial.write((uint8_t*)&e.commandFrameCounterDelta, 2);
    Serial.write((uint8_t*)&e.commandProcessTime, 4);
}

void processGetPerfLog() {
    // Cabecalho
    Serial.write(0xCA);
    Serial.write(0xFE);
    Serial.write(CMD_GET_PERF_LOG);
    Serial.write(STATUS_SUCCESS);

    // Numero de entradas
    Serial.write(perfIndex);

    // Payload
    for (uint8_t i = 0; i < perfIndex; i++) {
        sendPerfLogEntry(perfBuffer[i]);
    }

    // Reset
    perfIndex = 0;
}

// INTRUMENTACAO - Funcao para REGISTRAR ESTATISTICAS DE PERFORMANCE
void registerPerformanceStats() {
  if (perfIndex < 99) {
    perfBuffer[perfIndex] = { frameCounter, frameRate, frameJitter, commandSequence, (uint16_t)(commandEndCounter-commandStartCounter), commandProcessTime };
    perfIndex = (perfIndex + 1) % PERF_BUFFER_SIZE;
  }
}
\end{lstlisting}

\section{Funcionalidades de Instrumentação}

\subsection{Variáveis de Análise de Performance}

A versão instrumentada adiciona as seguintes variáveis para coleta de métricas:

\begin{itemize}
    \item \textbf{frameCounter:} Contador absoluto de frames/loops executados
    \item \textbf{frameRate:} Taxa de execução do loop principal em Hz
    \item \textbf{frameJitter:} Variação no tempo entre frames consecutivos
    \item \textbf{commandSequence:} Identificador sequencial de comandos recebidos
    \item \textbf{commandStartCounter/EndCounter:} Frames de início e fim de processamento
    \item \textbf{commandProcessTime:} Tempo total de processamento do comando em microssegundos
\end{itemize}

\subsection{Pinos de Debug para Osciloscópio}

Para análise com osciloscópio, foram definidos pinos de saída digital:

\begin{itemize}
    \item \textbf{PIN\_TRIGGER\_RX (2):} Pulso quando recebe comando
    \item \textbf{PIN\_TRIGGER\_TX (3):} Pulso quando envia resposta
    \item \textbf{PIN\_FRAME\_TOGGLE (4):} Toggle a cada execução do loop
    \item \textbf{PIN\_BUSY (5):} Nível alto durante processamento de comando
\end{itemize}

\subsection{Buffer de Performance}

O sistema mantém um buffer circular de 100 entradas com as seguintes informações por comando:

\begin{lstlisting}[language=C++, caption={Estrutura PerfLog para dados de performance}, label=lst:perflog_struct]
struct PerfLog {
  unsigned long frameCounter;        // Contador absoluto de frames
  uint16_t frameRate;                // Frame rate
  uint16_t frameJitter;              // Diferenca entre frames consecutivos
  uint16_t commandSequence;          // Identifica o comando
  uint16_t commandFrameCounterDelta; // Distancia em frames do inicio ao fim
  unsigned long commandProcessTime;  // Tempo de execucao em microssegundos
};
\end{lstlisting}

\subsection{Comando Adicional de Performance}

Foi implementado o comando \texttt{CMD\_GET\_PERF\_LOG (0xF3)} que permite baixar todos os dados de performance coletados:

\begin{itemize}
    \item \textbf{Formato:} [0xCA][0xFE][0xF3]
    \item \textbf{Resposta:} Cabeçalho + número de entradas + dados serializados
    \item \textbf{Funcionalidade:} Transmite buffer completo e o reseta
\end{itemize}

\section{Integração com Sistema de Teste}

\subsection{Loop Principal Instrumentado}

O loop principal foi modificado para incluir:

\begin{enumerate}
    \item Medição precisa de tempo de frame usando \texttt{micros()}
    \item Cálculo em tempo real de frame rate e jitter
    \item Sinalização visual através dos pinos de debug
    \item Controle de frequência para manter ~100Hz
    \item Função de exemplo \texttt{calculation()} para simular carga de trabalho
\end{enumerate}

\subsection{Uso da Instrumentação}

Para utilizar a versão instrumentada:

\begin{enumerate}
    \item Conectar osciloscópio aos pinos 2-5 para análise temporal
    \item Usar a ferramenta host para coletar dados via comando 0xF3
    \item Executar testes de latência, throughput e jitter
    \item Analisar métricas coletadas para otimização de performance
\end{enumerate}

\section{Especificações Técnicas da Instrumentação}

\subsection{Precisão Temporal}
\begin{itemize}
    \item \textbf{Resolução:} 4 microssegundos (função micros() do Arduino)
    \item \textbf{Overflow:} Aproximadamente 70 minutos
    \item \textbf{Jitter medido:} Diferença absoluta entre períodos consecutivos
\end{itemize}

\subsection{Buffer de Performance}
\begin{itemize}
    \item \textbf{Tamanho:} 100 entradas (configurável via PERF\_BUFFER\_SIZE)
    \item \textbf{Tipo:} Buffer circular com reset automático
    \item \textbf{Payload:} 16 bytes por entrada
    \item \textbf{Capacidade total:} 1600 bytes de dados de performance
\end{itemize}

\subsection{Sinais de Debug}
\begin{itemize}
    \item \textbf{Duração do pulso:} 10 microssegundos
    \item \textbf{Nível lógico:} 0V/5V compatível com osciloscópio
    \item \textbf{Frequência do toggle:} ~100Hz (acompanha o loop principal)
\end{itemize}
