% ============================================================================
% APÊNDICE A - CÓDIGO FONTE DO PROTOCOLO DESTRA PARA ARDUINO
% ============================================================================
\chapter{Protocolo DESTRA Arduino}

\section{Implementação Base do Protocolo}

Este apêndice apresenta a implementação completa do protocolo DESTRA para Arduino, incluindo toda a lógica de comunicação serial para operações peek/poke.

\subsection{Implementação Completa - destra\_protocol.ino}

\begin{lstlisting}[language=C++, caption={Código completo do protocolo DESTRA para Arduino}, label=lst:destra_protocol, basicstyle=\small\ttfamily, breaklines=true, numbers=left, numberstyle=\tiny, stepnumber=1, showstringspaces=false]
/*
 * ============================================================================
 * Arquivo: destra_protocol.ino
 * Autor: Sandro Fadiga
 * Instituicao: EESC - USP (Escola de Engenharia de Sao Carlos)
 * Projeto: DESTRA - DEpurador de Sistemas em Tempo ReAl
 * Data de Criacao: 09/01/2025
 * Versao: 1.0
 * 
 * Descricao:
 *   Implementacao do protocolo DESTRA para Arduino.
 *   Este arquivo contem toda a logica de comunicacao serial para
 *   operacoes peek/poke, permitindo leitura e escrita de memoria
 *   em tempo real para depuracao de sistemas embarcados.
 * 
 * Protocolo:
 *   - Palavras magicas: 0xCA 0xFE
 *   - Comandos: PEEK (0xF1), POKE (0xF2)
 *   - Enderecamento: 16 bits (0x0100 - 0x08FF para Arduino Uno)
 *   - Tamanho de dados: 1-8 bytes por operacao
 *   - Comunicacao: Serial 115200 baud, 8N1
 * 
 * Funcionalidades:
 *   - destraSetup(): Inicializa a comunicacao serial
 *   - destraHandler(): Processa comandos recebidos (nao bloqueante)
 *   - processPeekRequest(): Le dados da memoria
 *   - processPokeRequest(): Escreve dados na memoria
 *   - Maquina de estados para parsing de comandos
 *   - Validacao de enderecos e tamanhos
 *   - Echo de confirmacao para todos os bytes recebidos
 * 
 * Formato dos Pacotes:
 *   PEEK: [0xCA][0xFE][0xF1][ADDR_L][ADDR_H][SIZE]
 *   POKE: [0xCA][0xFE][0xF2][ADDR_L][ADDR_H][SIZE][DATA...]
 * 
 * Codigos de Status:
 *   - 0x00: Sucesso
 *   - 0x01: Erro de faixa de endereco
 *   - 0x02: Erro de tamanho
 * 
 * Requisitos:
 *   - Arduino Uno ou compativel
 *   - Memoria RAM acessivel: 0x0100 - 0x08FF
 * 
 * Uso:
 *   1. Incluir este arquivo no projeto Arduino
 *   2. Chamar destraSetup() no setup()
 *   3. Chamar destraHandler() no loop()
 * 
 * Licenca: MIT
 * ============================================================================
 */

#include <Arduino.h>

// Constantes de comunicacao serial
#define SERIAL_START_MARKER 0xCAFE
#define CMD_PEEK 0xF1
#define CMD_POKE 0xF2
#define STATUS_SUCCESS 0x00
#define STATUS_ADDRESS_RANGE_ERROR 0x01
#define STATUS_SIZE_ERROR 0x02
#define BAUD_RATE 115200
#define BUFFER_SIZE 64 // Buffer para dados recebidos

// Estados da maquina de estados serial
enum DestraState {
  WAIT_START_HIGH,
  WAIT_START_LOW,
  WAIT_COMMAND,
  WAIT_ADDRESS_LOW,
  WAIT_ADDRESS_HIGH,
  WAIT_SIZE,
  WAIT_VALUE,
  PROCESS_REQUEST
};

// Variaveis de comunicacao serial
DestraState destraState = WAIT_START_HIGH;
uint8_t destraCommand = 0;
uint16_t destraAddress = 0;  // Endereco de 16 bits
uint8_t destraSize = 0;
uint8_t addressLow = 0;
uint8_t addressHigh = 0;
uint8_t destraValueBuffer[8];  // Buffer para bytes de valor do POKE
uint8_t destraValueIndex = 0;   // Indice para buffer de valor

// Coloque-me no inicio do seu setup()
void destraSetup() {
  // Inicializar comunicacao serial
  Serial.begin(BAUD_RATE);
  // Aguardar conexao da porta serial (necessario para placas USB nativas)
  while (!Serial) {
    ; // Aguardar conexao da porta serial
  }
  destraState = WAIT_START_HIGH;
}

// Coloque-me no inicio do seu loop()
void destraHandler() {
// Funcao para lidar com comunicacao serial destra (nao bloqueante)
  while (Serial.available() > 0 && destraState != PROCESS_REQUEST) {
    uint8_t inByte = Serial.read();
  
    // Maquina de Estados do Pacote/Requisicao     
    switch (destraState) {
      // Pacote PEEK/POKE comeca com 0xCAFE
      case WAIT_START_HIGH:
        if (inByte == 0xCA) {
          int bytesAvailable = Serial.availableForWrite();
          destraState = WAIT_START_LOW;
        }
        break;
        
      case WAIT_START_LOW:
        if (inByte == 0xFE) {
          destraState = WAIT_COMMAND;
        } else {
          destraState = WAIT_START_HIGH;
        }
        break;
        
      case WAIT_COMMAND:
        destraCommand = inByte;
        if (inByte == CMD_PEEK || inByte == CMD_POKE) {
          destraState = WAIT_ADDRESS_LOW;
        } 
        else {
          destraState = WAIT_START_HIGH;
        }
        break;
        
      case WAIT_ADDRESS_LOW:
        addressLow = inByte;
        destraState = WAIT_ADDRESS_HIGH;
        break;
        
      case WAIT_ADDRESS_HIGH:
        addressHigh = inByte;
        // Combinar para endereco de 16 bits (little endian)
        destraAddress = addressLow | (addressHigh << 8);
        destraState = WAIT_SIZE;
        break;
        
      case WAIT_SIZE:
        destraSize = inByte;
        if (destraCommand == CMD_PEEK) {
          destraState = PROCESS_REQUEST;
        }
        else if (destraCommand == CMD_POKE) {
          destraValueIndex = 0;  // Resetar indice do buffer de valor
          destraState = WAIT_VALUE;
        }
        else {
          destraState = WAIT_START_HIGH;
        }
        break;

      case WAIT_VALUE:
        // Verificar se o indice esta dentro dos limites do buffer
        if (destraValueIndex < 8 && destraValueIndex < destraSize) {
          // Armazenar o byte de valor
          destraValueBuffer[destraValueIndex] = inByte;
          destraValueIndex++;
        }
        // Verificar se recebemos todos os bytes de valor
        if (destraValueIndex >= destraSize) {
          destraState = PROCESS_REQUEST;
        }
        // Caso contrario, permanecer em WAIT_VALUE para coletar mais bytes
        break;
    }
  }
  
  // Processar a requisicao se tivermos uma mensagem completa
  if (destraState == PROCESS_REQUEST) {
    if (destraCommand == CMD_PEEK) {
      processPeekRequest();
    } else if (destraCommand == CMD_POKE) {
      processPokeRequest();
    }
    destraCommand = 0;
    destraState = WAIT_START_HIGH;  // Resetar para proxima requisicao
  }
}


// Funcao para processar requisicao peek e enviar resposta
void processPeekRequest() {
  // Enviar cabecalho da resposta
  Serial.write(0xCA);
  Serial.write(0xFE);
  Serial.write(CMD_PEEK);
  
  // Validar faixa de endereco (verificacao de seguranca opcional)
  if (destraAddress < 0x100 || destraAddress > 0x8FF) {  // Faixa de RAM do Arduino Uno
    Serial.write(STATUS_ADDRESS_RANGE_ERROR);
    return;
  }

  // Validar tamanho
  if (destraSize == 0 || destraSize > 8) {
    Serial.write(STATUS_SIZE_ERROR);
    return;
  }
  
  Serial.write(STATUS_SUCCESS);
  
  // Ler e enviar os dados solicitados
  uint8_t* ptr = (uint8_t*)destraAddress;
  for (uint8_t i = 0; i < destraSize; i++) {
    Serial.write(ptr[i]);
  }
}


// Funcao para processar requisicao poke e enviar resposta
void processPokeRequest() {
  // Enviar cabecalho da resposta
  Serial.write(0xCA);
  Serial.write(0xFE);
  Serial.write(CMD_POKE);
  
  // Validar faixa de endereco
  if (destraAddress < 0x100 || destraAddress > 0x8FF) {  // Faixa de RAM do Arduino Uno
    Serial.write(STATUS_ADDRESS_RANGE_ERROR);
    return;
  }

  // Validar tamanho (ja verificado na maquina de estados, mas dupla verificacao)
  if (destraSize == 0 || destraSize > 8) {
    Serial.write(STATUS_SIZE_ERROR);
    return;
  }
  
  // Escrever os dados na memoria
  uint8_t* ptr = (uint8_t*)destraAddress;
  for (uint8_t i = 0; i < destraSize; i++) {
    ptr[i] = destraValueBuffer[i];
  }
  
  // Enviar status de sucesso
  Serial.write(STATUS_SUCCESS);
  
  // Opcionalmente, ecoar de volta os dados escritos para verificacao
  // Isso ajuda a confirmar que a escrita foi bem-sucedida
  for (uint8_t i = 0; i < destraSize; i++) {
    Serial.write(ptr[i]);  // Ler de volta da memoria e enviar
  }
}
\end{lstlisting}

\section{Uso do Protocolo}

Para utilizar o protocolo DESTRA em um projeto Arduino, siga estes passos:

\begin{enumerate}
    \item Inclua o código acima no seu projeto Arduino (pode ser em um arquivo separado ou no sketch principal)
    \item No \texttt{setup()}, adicione: \texttt{destraSetup();}
    \item No \texttt{loop()}, adicione: \texttt{destraHandler();}
    \item Compile e envie o código para o Arduino
    \item Use a ferramenta DESTRA UI para conectar e interagir com o sistema
\end{enumerate}

\section{Exemplo de Integração}

\begin{lstlisting}[language=C++, caption={Exemplo de uso do protocolo DESTRA em um projeto}, label=lst:destra_exemplo, basicstyle=\small\ttfamily, breaklines=true]
// Exemplo de sketch Arduino usando o protocolo DESTRA
#include "destra_protocol.ino"  // Incluir o protocolo

// Variaveis do seu projeto
int sensorValue = 0;
float temperature = 25.5;
bool ledState = false;

void setup() {
  // Inicializar protocolo DESTRA
  destraSetup();
  
  // Suas inicializacoes do projeto
  pinMode(LED_BUILTIN, OUTPUT);
  pinMode(A0, INPUT);
}

void loop() {
  // Processar comandos DESTRA (nao bloqueante)
  destraHandler();
  
  // Sua logica principal do projeto
  sensorValue = analogRead(A0);
  temperature = sensorValue * 0.48828125; // Conversao para temperatura
  
  digitalWrite(LED_BUILTIN, ledState);
  
  delay(100);
}
\end{lstlisting}

\section{Especificações Técnicas}

\subsection{Parâmetros de Comunicação}
\begin{itemize}
    \item \textbf{Velocidade:} 115200 baud
    \item \textbf{Configuração:} 8N1 (8 bits, sem paridade, 1 stop bit)
    \item \textbf{Palavras mágicas:} 0xCA 0xFE
    \item \textbf{Timeout:} 2 segundos
\end{itemize}

\subsection{Faixa de Endereços}
\begin{itemize}
    \item \textbf{RAM Arduino Uno:} 0x0100 - 0x08FF
    \item \textbf{Tamanho máximo por operação:} 8 bytes
    \item \textbf{Endereçamento:} 16 bits (little-endian)
\end{itemize}

\subsection{Códigos de Status}
\begin{itemize}
    \item \textbf{0x00:} Operação bem-sucedida
    \item \textbf{0x01:} Erro de faixa de endereço
    \item \textbf{0x02:} Erro de tamanho inválido
\end{itemize}
